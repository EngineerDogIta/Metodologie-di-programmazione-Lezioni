# Metodologie di programmazione: dispensa Lezioni
Una dispensa di tutti i codici sorgenti dei programmi spiegati a lezione, da P.Cenciarelli nel corso universitario di Metodologie di Programmazione

[LEZIONE_1](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_1) -> `divisione.java` il seguente codice esegue una divisione con un algoritmo egiziano

[LEZIONE_2](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_2) -> `ArrayStack.java` una lista di interi in formato Stack tipo FIFO `Pile.java` esegue un test dell'ArrayStack.java `Var.java` implementa le variabili come tipo di dato astratto `Variabili.java` Test di Var.java

[LEZIONE_3](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_3) -> `ArrayStack2.java` implementa il tipo di dato astratto degli stack con eccezioni `ArrayStack3.java` implementa il tipo di dato astratto degli stack con altre eccezioni `FullMaxStackException.java` gestore della eccezione per ArrayStack `FullStackException.java` gestore della eccezione per ArrayStack `Pile2.java` Test dei tipi di dati astratti con le eccezioni

[LEZIONE_4](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_4) -> `IntList.java` liste di interi `ListStack.java` implementa gli stack come liste `TestListStack.java` test delle pile fatte a lista `TestListe.java` test liste

[LEZIONE_5](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_5) -> `C1.java` la superclasse di C2 `C2.java` la sotto classe di C1 `test.java` test dell'ereditarietà

[LEZIONE_6](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_6) -> classi nel package primo `primo.C1.java` la superclasse di C2 `primo.C2.java` la sotto classe di C1 superclasse di C3 `primo.C3.java` la sotto classe di C2 `primo.PensieroStupendo.java` estende una classe che appartiene ad un'altro package `test6.java` test dell'ereditarietà; classi del package secondo `secondo.Potenze.java` uso dei modificatori di accessosu alcune potenze di due

[LEZIONE_7](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_7) -> `Benchmark.java` testa il tempo di esecuzione del metodo astratto azione `ConcreteBenchmark.java` prende in input da args[0] il numero di esecuzioni (numerotest) crea un benchmark e calcola il tempo di numerotest esecuzioni del metodo azione `Echo.java` Stampa i parametri che vengono passati al main(args[]) `IntVar.java` contratto delle variabili intere `IntVar1.java` implementa le variabili intere `IntVar2.java` implementa le variabili intere memorizzandole `Leggibile.java` interfaccia per sola lettura `Quarantadue.java` una classe con un metodo scrivi che stampa quarantadue `Scrivibile.java` interfaccia per sola scrittura `testVariabili.java` classe di test delle variabili

[LEZIONE_8](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_8) -> `Pac0.FilgiMiei.java` una classe del package Pac0 vengono definiti i nomi dei figlio e il numero dei figli `Pac0.TestFigli.java` test dei figli `Pac1.Tonno.java` un oggetto di tipo tonno `Pac1.Vertebrato.java` un'oggetto di tipo Vertebrato superclasse di tonno `Pac2.Gatto.java` oggetto di tipo gatto che estende la classe vertebrato `Pac3.ArrayStack.java.` implementa l'interfaccia Stack tipo astratto `Pac3.EmptyStackException.java` gestore dell'eccezione `Pac3.FullStackException.java` gestore dell'eccezione `Pac3.IntList.java` Lista di interi `Pac3.ListStack.java` lista stack `Pac3.ReverseStack.java` lista inversa LIFO `Pac3.Stack.java` Nelle implementazioni, i metodi devono essere dichiarato public anche se qui non compare il modificatore d'accesso: in una interfaccia tutti i metodi sono implicitamente public! Anche le interfacce possono avere attributi, che sono implicitamente static

[LEZIONE_9](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_9) -> `Stato.java` classe tipo stato `TestLocal.java` Classe *locale* a un metodo (m). Visibilita' e accesso alle varibili locali `TestStati.java` test della finanza

[LEZIONE_10](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_10) -> `Sequenze.java` uso della classe generica LinKedList

[LEZIONE_11](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_11) -> `sottotipo.C1.java` supertipo di C2 `sottotipo.C2.java` sottotipo di C1 `sottotipo.Gen1.java` supertipo di gen2 e test di genericità `sottotipo.Gen2.java` test sottotipi generici `wildcard.C3.java` importazione di una classe da un'altro package `wildcard.Gen.java` una classe generica da implementare nel test `wildcard.WildTest.java` un test per l'utilizzo del tipo wildcard e delle sue funzionalità

[LEZIONE_12](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_12) -> `Anonymous.java` Due modi di creare classi anonime: estendendo una classe o implementando un'interfaccia in questa classe viene creata una classe anonima di quell'oggetto `Leggibile.java` interfaccia da implementare `MyLeggibile.java` implementazione classica

[LEZIONE_13](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_13) -> `Funzio.java` un'interfaccia per dimostrare le funzionalità delle funzioni lambda `FunzioTest.java` due lambda istanze dell'interfaccia funzionale Funzio; in entrambi i casi il contesto permette di inferire il tipo delle espressioni. Nota: le espressioni lambda denotano oggetti di classi anonime ma non vengono creati mediante la new! `LambdaTest.java` uso delle funzioni anonime per scorrere su un array o lista

[LEZIONE_14](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_14) -> `NarcoStampatore.java` stampatore con ritardo estendendo la classe stampatore usando sleep() `SillyTest.java` crea ed esegue thread a caso inutili `Snaporaz.java` gioca a snapo-snapo-raz `Stampatore.java` classe che estende Thread, stampa la parola inserita nell'oggetto quando parte il thread `StampatoreCompulsivo.java` estende la classe NarcoStampatore quando viene iniziato il thread aziona lo sleep per un ritardo definito nel parametro, se interrotto stampa un messaggio

[LEZIONE_15](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_15) -> `ArrayStack.java` implementa il tipo di dato astratto degli stack **(versione con errori!)** Solo la pop() è sincronizzata. Non sincronizzando la pop() due pusher concorrenti potrebbero estrarre lo stesso elemento `DeadLock.java` Creazione ad arte di una situazione di deadlock: due thread di tipo DeadManWalking tentano entrambi di acquisire in sequenza due lock su due monitor, ma lo fanno in ordine inverso. Usando la sleep per interfogliare opportunamente i thread (vedi DeadManWalking), si va in blocco! `DeadManWalking.java` Due lock annidati su monitor diversi `EmptyStackException.java` Gestione eccezzione `FullStackException.java` Gestione eccezzione `Inghippo.java` Due thread eseguono la pop() su uno stack. Se non sincronizziamo (vedi ArrayStack) potrebbe accadere di estrarre due volte lo stesso elemento e perderne uno! `Popper.java` oggetto thread che toglie un elemento dallo stack

[LEZIONE_16](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_16) -> `ArrayStackBello.java` implementa il tipo di dato astratto degli stack in un contesto concorrente. Risolve con il problema di ArrayStackBrutto usando wait e notify `ArrayStackBrutto.java` implementa il tipo di dato astratto degli stack in contesto concorrente. Si sincronizzano le sezioni critiche di push e pop. `Popper.java` oggetto thread esegue una pop su pila `Pusher.java` esegue una push di valore su pila `Stack.java` interfaccia void push() e pop() `Test.java` testa l'implementazione sbagliata e quella corretta (con wait e notify) di una pila in regime di concorrenza `YesWeCan.java` I metodi wait, notify e notifyAll possono essere invocati esclusivamente all'interno di codice sincronizzato, utilizzando il lock dell'oggetto sul quale vengono invocati. L'invocazione può essere fatta direttamente dal codice sincronizzato o indirettamente da uno dei metodi invocati al suo interno. Qualora si cercasse di invocare questi metodi su di un oggetto del quale non si possegga il lock, si otterrebbe un'eccezione

[LEZIONE_17](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_17) -> `BadBoys.java` Lancia e poi interrompe tre bad boys. Uno e' di una classe che estende Thread, gli altri due sono thread tout-court, costruiti con un runnable `EnricoBossi.java` simula il meccanismo dell'interrupt testando una sua variabile `JimKongOn.java` se interrotto stampa BOOM! oppure lo fa se finisce il tempo `RonaldDrump.java` fa la stessa cosa come KimKongOn ma con il currentThread

[LEZIONE_18](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_18) -> `Ballo.java` Dove si incontrano bulli e pupe `BulliePupe.java` Lancia due bulli e due pupe che si incontrano al ballo; alla fine del ballo (100 millisecondi) termina i quattro partecipanti `Bullo.java` Essenzialmente, prende una pupa dalla coda e la bacia, fino alla fine del ballo. Quando esegue extract() potrebbe bloccarsi (nel caso non ci siano pupe) in attesa sulla coda del ballo  `MyListElem.java` linked list `Pupa.java` Essenzialmente, una pupa si inserisce (il thred come oggetto) nella coda del ballo e attende (usando se stessa come monitor!!!) che un bullo la risvegli, e ripete fino alla fine del ballo. `SynchroCoda.java` implementazione con linked list del tipo di dato astratto delle code in ambiente multithreading

[LEZIONE_19](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_19) -> `HuskyDog.java` costruttore per il test della riflessione `TestReflection.java` Viene creato un oggetto di tipo Class e viene usato per costruire un oggetto della classe corrispondente e invocarne un metodo. Class e' un tipo generico!

[LEZIONE_20](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_20) -> `Agente.java` interfaccia per l'azione `AnnotatedAStack.java` Annotated ArrayStack ridefinisce lunghezza lunghezza(). Serve solo a mostrare che IntelliJ usa le annotazioni (@override) Nota: bisogna definire un costruttore dato che non c'e' un costruttore di default in ArrayStack! `ArrayConsistency.java` interfaccia con il tipo annotazione, sono ammessi solo metodi senza parametri `ArrayStack.java` dato astratto con condizione di consistenza sull'indice top `MyAgente.java` costruttore con metodo azione implementa Agente `TestAgente.java` Supponiamo di voler scrivere un main per testare un homework dove si chiede di implementare l'interfaccia Agente. Tipicamente gli studenti consegnano classi che non si chiamano come gli e' stato chiesto (MyAgente), o che
 non implementano Agente, con i giusti metodi (azione)... Usando la reflection si può scrivere un tester per l'homework senza avere
 a disposizione la classe MyAgente: si trattano a tempo di esecuzione gli errori che altrimenti verrebbero intercettati dal compilatore `Violazione.java` mostra la possibilita' di violare un campo privato mediante la reflection, con conseguente malfunzionamento della struttura dati (stack)

[LEZIONE_21](https://github.com/EngineerDogIta/Metodologie-di-programmazione-Lezioni/tree/master/Lezione_21) -> `Aegyptian.java` moltiplicazione egiziana con asserzioni. Metodo delle invarianti `DivisioneAsserts.java` utlizzo delle asserzioni per la divisione `Shibuya_Crossing.ogv.480p.webm` *TODO* FIle da eliminare
